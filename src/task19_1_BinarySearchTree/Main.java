package task19_1_BinarySearchTree;

import java.util.Arrays;

public class Main {

    public static void main(String[] arg) {
        System.out.println("Домашнее задание к занятию 5. Пирамиды и бинарные деревья поиска\n " +
                "Построение идеального биндерева поиска\n");

        int[] arr = new int[]{10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52};
        System.out.println(Arrays.toString(arr));
        System.out.println(arr.length);

        build(arr);
    }

    private static void mark(int[] arr, int left, int right, int level, int[] levels) {

        if (left == right) {
            levels[left] = level;

            System.out.println(" if (left == right)  left = " + left + ", right = " + right + ", level = " + level);

        } else {
            int middle = (left + right) / 2;
            levels[middle] = level;

            System.out.println("   levels[middle] = level ///middle = " + middle + "  //level = " + level);
            System.out.println(" 1 - mark(arr, left = " + left + ", right = " + right + ", level = " + level + ", levels) ");

            mark(arr, left, (middle - 1), (level + 1), levels);

            System.out.println("2 - mark(arr, left = " + left + ", right = " + right + ", level = " + level + ", levels) ");

            mark(arr, (middle + 1), right, (level + 1), levels);

        }

    }

    private static void build(int[] arr) {

        int[] levels = new int[arr.length];

        mark(arr, 0, (arr.length - 1), 0, levels);

        for (int level = 0; level < (levels[0] + 1); level++) {

            for (int i = 0; i < arr.length; i++) {

                if (levels[i] == level) {
                    System.out.print(arr[i]);
                } else {
                    System.out.print("  ");
                }
            }
            System.out.println();

        }

    }

}



/*

Построение идеального биндерева поиска
У вас есть отсортированный массив двузначных чисел без повторов размером в 2k-1 для какого-нибудь k, т.е. вам гарантируется что размер может быть 3 (22-1), 15 (24-1), 1023 (210-1), но не 11 или 30. Это позволит вам не заморачиваться с проблемами при делении пополам :)

Вам надо написать функцию, которая возьмёт этот массив и выведет на экран бинарное дерево поиска из элементов этого дерева, которое будет полным двоичным деревом. Условие на размер массива гарантирует, что такое дерево всегда можно построить, более того, только на последнем уровне у узлов не будет детей.

Например, у вас есть массив [10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52].

Вам надо вывести бинарное дерево в таком виде:

              31
      19              43
  13      25      37      49
10  16  22  28  34  40  46  52
Заметьте, что стрелочки мы не рисовали, но кто является чьим ребёнком можно догадаться: у 31 ребёнок 19 и 43, у 25 - 22 и 28, у 43 - 37 и 49. Для каждого узла дерева соблюдается требование, наложенное на бинарные деревья поиска - левый ребёнок и все его потомки меньше, правый и все его потомки - больше.

Асимптотика в данном задании не важна.

Решение
Давайте сперва найдём для каждого элемента массива уровень дерева, на котором он должен быть (корень на нулевом уровне, дальше по увеличению).

Тк такое полное бинарное дерево симметрично в плане своей структуры, мы знаем, что слева от корня будет столько же элементов, сколько и справа. Если мы возьмём элемент посередине массива, то слева и справа будет одинаковое количество элементов, также благодаря отсортированности слева будут элементы только меньшие, а справа только большие. Значит этот элемент и есть корень нашего дерева и его уровень 0.

Решим задачу рекурсивно: левым ребёнком у корня будет элемент, который был бы корнем полного бинарного дерева поиска, запусти мы алгоритм от левой половины исходного массива. Аналогично для правого ребёнка.

Учитывая всё вышесказанное, давайте напишем рекурсивную функцию mark, которая принимает массив, левую и правую границы рассматриваемого участка массива, текущий уровень и массив, куда для каждого элемента исходного массива мы запишем его уровень в дереве. Результатом вызова этой функции mark(arr, 0, длина(arr) - 1, 0, пустой массив levels) в массиве levels в каждой ячейке будет лежать уровень элемента в дереве.

mark(arr, left, right, level, levels):
  if left == right
    levels[left] = level
    выход
  middle = (left + right) / 2
  levels[middle] = level
  mark(arr, left, middle - 1, level + 1, levels)
  mark(arr, middle + 1, right, level + 1, levels)
После того как мы разметим каждый элемент на соответствующий уровень, будем выводить уровни дерева по очереди, построчно. Для этого пройдёмся циклом со счётчиком текущего уровня, а для каждого уровня пройдёмся циклом по массиву меток. Если для элемента в массиве уровней стоит наш текущий выводимый уровень, то мы напечатаем элемент, если нет, то напечатаем пропуск.

build(arr):
  levels = [длина(arr) нулей]
  mark(arr, 0, длина(arr) - 1, 0, levels)
  for level от 0 до максимум_среди(levels) + 1
    for i от 0 до длина(arr):
      if levels[i] == level:
        напечатаем arr[i]
      else:
        напечатаем два пробела, тк числа двузначные
    напечатаем перенос строки

 */